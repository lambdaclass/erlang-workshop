* Erlang basics

** Data types

- term: any data type
- integer
- float
- atom: a literal, constant with a name (e.g: `foo`)
- string
- bit strings: `<<"foo bar">>`
- pid
- list
- tuple
- record
- map

** Pattern matching

In Erlang you don't have the usual assignment operation for variables, instead you bound them using pattern matching.

#+BEGIN_SRC erlang
%% We pattern match right-hand term to left-hand pattern
Variable = foo
%% Varibale is bound to the value foo

[FirstElement | _] = [1,2,3]
%% FirstElement is bound to the value 1
#+END_SRC

** Functions
A function declaration is conformed by one or more function clauses, this are made up by a head (signature) and its body.

#+BEGIN_SRC erlang
foo(Arg1, [] = ListArg) ->
  magic;
foo(Arg1, [ListArg1, | _] = ListArg) ->
  magic2.
#+END_SRC

Also, function clauses can have a guard to validate that it is the correct match
#+BEGIN_SRC erlang
greater_thant_2(Num) when num > 2 ->
  true;
greater_thant_2(_) ->
  false;
#+END_SRC

** Exercise 1

Write a function to calculate the factorial of N

Solution:
#+BEGIN_SRC erlang
factoria(1) ->
  1;
factorial(Num) ->
  Num * factorial(Num - 1).
#+END_SRC

** Exercise 2

[Erlings: Sum of Values](https://github.com/lambdaclass/erlings/tree/master/sequential/maps#sum-of-values)

* Erlang Process

** Process creation
How to create (spawn) a process:

#+BEGIN_SRC erlang
spawn(Module, Fun, Args) -> pid()
#+END_SRC

`spawn` creates a new process and returns its PID. The new process will start executing in `Module:Fun(Arg0, ..., ArgN)`

** Registering a process
Instead of addressing a process by its PID we can register it with a name and refer to it using that. The name must be an atom and will be automatically unregistered when the process terminates.

#+BEGIN_SRC erlang
%% Associates name Name with process Pid
register(Name, Pid) -> true

%% Returns a list of names that have been registered
registered()

%% Returns the Pid registered under Name, or undefined if the name is not registered
whereis(Name) -> Pid | undefined
#+END_SRC

** Sending and receiving messages
Processes can communicate by sending messages between them. Each process has a mailbox (queue) from which it will look for new messages that match the receiving pattern or for timeout to happen.

To send a message we use the send operator `!`:

#+BEGIN_SRC erlang
%% Send by PID
Pid ! Msg.
self() ! [blob].
pid(0, 118, 0) ! bar.

%% Send by registered name
Name ! {Stuff1, Stuff2}.
proc1 ! foo.
#+END_SRC

To receive a message (pop it from mailbox) we call `receive`, optionally we can also use  `after` for a timeout:

#+BEGIN_SRC erlang
receive
  Pattern1 [when Guard1] ->
    Body1;
  .
  .
  .
  PatternN [when GuardN] ->
    BodyN
after
  60000 ->
    BodyAfter
end
#+END_SRC

** Process dictionary
Each process has its own dictionary, which you can access using the following BIFs:

#+BEGIN_SRC erlang
%% Returns the entire process dictionary.
get() -> [{Key1, Val1}, ...]

%% Returns the item associated with Key or `undefined`
get(Key) -> Item | undefined

%% Returns a list of all keys whose associated value is Value.
get_keys(Value) -> [...]

%% Associate Value with Key. Returns the old value associated with Key or `undefined` if no such association exists.
put(Key, Value) -> OldValue | undefined

%% Erases the entire process dictionary. Returns the entire process dictionary before it was erased.
erase() -> [{Key1, Val1}, ...]

%% Erases the value associated with Key. Returns the old value associated with Key or undefined if no such association exists.
erase(Key) -> OldValue | undefined
#+END_SRC

* Exercise 3

[Erlings: Calculator](https://github.com/lambdaclass/erlings/blob/master/concurrent/calculator)

* OTP

Erlang comes with OTP (Open Telecom Platform), this is a framework that groups repeating and essentials tasks into librarires.

This libraries work by using an abstraction presented by Erlang/OTP called `behaviors`, this allow you to have generic code and then specify needed callbacks for the module that wants to implement the behavior.

The main behaviors you will used are:

- gen_*
  - gen_server
  - gen_event
  - gen_statem
- supervisor
- application

* Supervisors

** Linking

A link is a relationship between two processes in which whenever either dies in an unexpected way the other one dies also.

You can prevent a linked process from dying when the other dies unexpectedly by trapping exit signals (`process_flag(trap_exit, true)`)

This will make the exit signlas received by the trapping process become messages instead (`{'EXIT', FromPid, Reason}`).

** Supervision tree

Erlang/OTP applications work by using a supervisor tree to supervise all the processes (well, the important ones) in case any one fails and restart it.

Basically a root supervisor (process) which spawns either workers or supervisors processes, those supervisors processes can further spawn other workes or supervisors.

This is done using the `supervisor behavior`, this behavior just needs one single callback `init/1` that returns `{ok, {{RestartStrategy, MaxRestart, MaxTime}, [ChildSpecs]}}.`.

Let's explain those return values:
- `RestartStrategy`: one_for_one, one_for_all, rest_for_one, simple_one_for_one
- `MaxRestart` and MaxTime: if more than `MaxRestart` happen in `MaxTime` the supervisor gives up and kills itself.
- ChildSpec: `{ChildId, StartFunc, Restart, Shutdown, Type, Modules}`
  - ChildId: Internal name used by the supervisor
  - StartFunc: `{M, F, A}` to start the child with
  - Restart: How to react when the child dies: `permanent`, `temporary`, or `transient`
  - Shutdown: Timeout for child shutdown
  - Type: `worker` or `supervisor`
  - Modules: is a list of one element, the name of the callback module used by the child behavior, or `dynamic` if not known.

#+BEGIN_SRC erlang
init(_) ->
  {ok, {{one_for_all, 5, 60},
        [{fake_id,
          {fake_mod, start_link, [SomeArg]},
          permanent,
          5000,
          worker,
          [fake_mod]},
        {other_id,
          {event_manager_mod, start_link, []},
          transient,
          infinity,
          worker,
          dynamic}]}}.
#+END_SRC

* Build tools

** Rebar3

The go to build tool for erlang projects right now is [rebar3](http://www.rebar3.org/)

- `rebar3 new <template> <project-name>`
- `rebar3 compile`
- `rebar3 shell`
- `rebar as <profile> tar`
- `rebar3 eunit`
- `rebar3 ct`

** rebar.config

#+BEGIN_SRC erlang
{deps, [
        {cowboy, "2.1.0"},
        {syn, "1.6.1"},
        {redbug, {git, "https://github.com/massemanet/redbug.git", {tag, "1.2.1"}}},
       ]}.

{relx, [{release, {exampleapp, "1"}, [exampleapp]},
         {dev_mode, true},
         {include_erts, false},
         {extended_start_script, true},
         {overlay_vars, "conf/local_vars.config"},
         {overlay, [{template, "conf/sys.config", "releases/{{default_release_version}}/sys.config"},
                    {template, "conf/vm.args", "releases/{{default_release_version}}/vm.args"}]}
         ]}.

{profiles, [{test, [{erl_opts, [nowarn_export_all]},
                    {relx, [{overlay_vars, "conf/test_vars.config"}]}]},
            {prod, [{relx, [{dev_mode, false},
                            {overlay_vars, "conf/prod_server_vars.config"},
                            {include_src, false},
                            {vm_args, "./conf/vm.args"},
                            {extended_start_script, true}]}]}]}.
#+END_SRC

* Distributed Erlang

** Fallacies of distributed computing

- The network is reliable
- There is no latency
- Bandwidth is infinite
- The network is secure
- Topology doesn't change
- There is only one administrator
- Transport cost is zero
- The network is homogeneous

** CAP theorem

Choose 2:

- Consistency
- Availability
- Partition tolerance

** Starting a node
Erlang is designed with distribution in mind. A distributed Erlang system consist (cluster) on a number of Erlang runtime systems (nodes) communicating with each other.

All features learned for local system using a PID work on a distributed system, except for registering a name for a PID, that's local for each node.

A node is started by giving the Erlang runtime a name, either a short name (`-sname) or a long name (`-name`). Keep in mind a short named node can connect to a long named one and vice versa.

#+BEGIN_SRC erlang
%% erl -name dilbert
(dilbert@domain.example.com)1> node().
'dilbert@domain.example.com'

%% erl -sname dilbert
(dilbert@domain)1> node().
dilbert@domain
#+END_SRC

** Connecting nodes

Nodes in a cluster are loosely connected. The first time an interaction with another node is invoked (e.g. `spawn(Node,M,F,A)`) the connection attempt is done.

Connections are by default transitive. If node A connects to node B and then node B connects to node C, a connection between node A and C is established.

If a node goes down all connections to that node are removed.

* Exercise 4

[Remote Function Server](https://github.com/lambdaclass/erlings/tree/master/distributed/remote_fun)

* Debugging

** Tracing

Erlang offers a powerfull way of debugging called tracing.

The Erlang module `dbg` offers the functions needed to trace anything, but it's a bit overcomplicated to use.

In general you'll want to use the library [Redbug](https://github.com/massemanet/redbug), it's really easy to use and very powerfull.

#+BEGIN_SRC erlang
1> redbug:start("erlang:demonitor").
{30,2}
15:39:00 <{erlang,apply,2}> {erlang,demonitor,[#Ref<0.0.0.21493>]}
15:39:00 <{erlang,apply,2}> {erlang,demonitor,[#Ref<0.0.0.21499>]}
15:39:00 <{erlang,apply,2}> {erlang,demonitor,[#Ref<0.0.0.21500>]}
redbug done, timeout - 3

%% Trace on messages that the shell process receives.
2> redbug:start('receive',[{procs,[self()]}]).
{1,0}
15:15:47 <{erlang,apply,2}> <<< {running,1,0}
15:17:49 <{erlang,apply,2}> <<< timeout
redbug done, timeout - 2
#+END_SRC

* Project: Shortly

** Getting started with cowboy

Small, fast, modular HTTP server.

Let's implement a server with two endpoints:

- `/home`: returns the message "Hello World!"
- `/other/:word`: returns `:word`

First create the project using `rebar3 new app hello`, add cowboy (`{cowboy, "2.7.0"}`) as a dependency, and include it in your application.

Next we create the routes and initialize cowboy in our app:

#+BEGIN_SRC erlang
Dispatch = cowboy_router:compile([{'_', [{"/home", home_handler, []},
                                         {"/other/:word", other_handler, []}]}]),
{ok, _} = cowboy:start_clear(http, [{port, 8080}], #{env => #{dispatch => Dispatch}}),
#+END_SRC

Then we just need to create each of the module handlers we specified and the needed callbacks.

For the most simple handlers (the ones we want) we just need to implement the `init/2` callback.

#+BEGIN_SRC erlang
-module(home_handler).
-export([init/2]).

init(Req0, State) ->
  Req = cowboy_req:reply(200,
                         #{<<"content-type">> => <<"text/plain">>},
                         <<"Hello World!">>,
                         Req0),
  {ok, Req, State}.
#+END_SRC

#+BEGIN_SRC erlang
-module(other_handler).
-export([init/2]).

init(Req0, State) ->
  Word = cowboy_req:binding(word, Req0),
  Req = cowboy_req:reply(200,
                         #{<<"content-type">> => <<"text/plain">>},
                         Word,
                         Req0),
  {ok, Req, State}.
#+END_SRC

** Exercise: Shortly

Based on [Erlings: Shortly](https://github.com/lambdaclass/erlings/tree/master/libraries/shortly)

Create an `OTP` application using `rebar3` and [cowboy](https://github.com/ninenines/cowboy) that is capable of receiving long links and returning shorts ones:

- Receive a `HTTP POST` at `http://localhost:8080/<LONG_URL>` returning a shortened link.
- Receive a `HTTP GET` at `http://localhost:8080/<SHORT_URL>` returning the original long link.
- Accept websocket connections at `http://localhost:8080/news` and notify every time a new link is shortened.

BONUS: Create similar endpoints (`GET` and `POST`), but using `cowboy_rest` handler.
